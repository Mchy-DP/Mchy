<!--
WARNING: this file is automatically generated,  if you want to change something here you need to change the DocData object associated with the func/prop/etc.  DocData objects can be found in `/mchy/library`
-->
# std
## Functions
### area_replace
```
area_replace(pos1: std::Pos, pos2: std::Pos, old_block: str!, new_block: str!) -> null
```

### block_exists
```
block_exists(loc: std::Pos, required_block: str!) -> bool
```

### bool
```
bool(x: int) -> bool
```
> Cast an integer to a boolean
> 
> Params:
>   - **x**: The integer to cast
> 
> Returns:
>   - True if `x >= 1`, False otherwise
> 
> Note: Negative numbers are will be cast to false
### cmd
```
cmd(mc_cmd: str!) -> null
```

### effect_add
```
Entities.effect_add(effect: str!, seconds: int!, amplifier: int!, particles: bool! = True) -> null
```

### effect_clear
```
Entities.effect_clear(effect: str!? = null) -> null
```

### entity_exists
```
entity_exists(entity: Group[Entity]) -> bool
```

### fill
```
fill(pos1: std::Pos, pos2: std::Pos, block: str!, mine_existing: bool! = False, keep_existing: bool! = False) -> null
```

### give
```
Players.give(item: str!, count: int!, data: str! = {}) -> null
```

### has_tag
```
Entity.has_tag(tag: str!) -> bool
```

### kill
```
Entities.kill() -> null
```

### particle
```
particle(location: std::Pos, particle: str!, dx: float!, dy: float!, dz: float!, speed: float!, count: int!, force_render: bool! = False) -> null
```

### play_sound
```
Players.play_sound(sound_location: std::Pos, sound: str!, channel: str! = master, volume: float! = 1.0, pitch: float! = 1.0, min_volume: float! = 0.0) -> null
```

### print
```
print() -> null
```

### say
```
say(msg: str!) -> null
```

### setblock
```
setblock(location: std::Pos, block: str!, mine_existing: bool! = False, keep_existing: bool! = False) -> null
```

### spread
```
Entities.spread(center: std::Pos, radius: float!, spacing: float! = 0.0, respect_teams: bool! = False, max_height: int!? = null) -> null
```

### summon
```
summon(location: std::Pos, entity_type: str!, nbt_data: str!? = null) -> Entity
```

### tag_add
```
Entities.tag_add(new_tag: str!) -> null
```

### tag_count
```
Entity.tag_count() -> int
```

### tag_remove
```
Entities.tag_remove(target_tag: str!) -> null
```

### tp
```
tp(target_location: std::Pos) -> null
```

## Properties
### version
```
version -> int
```
> Get the version of the compiler that is generating the datapack
> 
> Returns:
>   - An integer of the form XXYYZZPP which links to the semantic versioning vXX.YY.ZZ.PP
## Chained methods
* ### colors
  ```
  (?).colors
  ```

  * ### aqua
    ```
    world.colors.aqua
    ```

  * ### black
    ```
    world.colors.black
    ```

  * ### blue
    ```
    world.colors.blue
    ```

  * ### cyan
    ```
    world.colors.cyan
    ```

  * ### dark_aqua
    ```
    world.colors.dark_aqua
    ```

  * ### dark_blue
    ```
    world.colors.dark_blue
    ```

  * ### dark_gray
    ```
    world.colors.dark_gray
    ```

  * ### dark_green
    ```
    world.colors.dark_green
    ```

  * ### dark_purple
    ```
    world.colors.dark_purple
    ```

  * ### dark_red
    ```
    world.colors.dark_red
    ```

  * ### gold
    ```
    world.colors.gold
    ```

  * ### gray
    ```
    world.colors.gray
    ```

  * ### green
    ```
    world.colors.green
    ```

  * ### hex
    ```
    world.colors.hex(color_code: str!)
    ```

  * ### light_purple
    ```
    world.colors.light_purple
    ```

  * ### lime
    ```
    world.colors.lime
    ```

  * ### red
    ```
    world.colors.red
    ```

  * ### white
    ```
    world.colors.white
    ```

  * ### yellow
    ```
    world.colors.yellow
    ```

* ### get_entities
  ```
  (?).get_entities()
  ```
  > Begin a partial selector targeting all entities that match the filters
  > 
  > Returns:
  >   - Partial Selector for Entity Groups
  * ### failing_predicate
    ```
    (?).get_entities().failing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities fail
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### from_position
    ```
    (?).get_entities().from_position(x: int!, y: int!, z: int!)
    ```
    > FILTER: Move the coordinates the selector tests from to set coordinates rather than executor coordinates
    > 
    > Params:
    >   - **x**: The x coordinate to originate location based selections at
    >   - **y**: The y coordinate to originate location based selections at
    >   - **z**: The z coordinate to originate location based selections at
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_radius
    ```
    (?).get_entities().in_radius(min: float!? = null, max: float!? = null)
    ```
    > FILTER: Filter out all entities not between the min and max distance
    > 
    > Params:
    >   - **min**: The minimum distance
    >   - **max**: The maximum distance
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_team
    ```
    (?).get_entities().in_team(team: str!?)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **team**: The name of the team valid entities must be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_volume
    ```
    (?).get_entities().in_volume(dx: int!, dy: int!, dz: int!)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **dx**: Makes the offset point `dx` away from the selector location
    >   - **dy**: Makes the offset point `dy` away from the selector location
    >   - **dz**: Makes the offset point `dz` away from the selector location
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### matching_nbt
    ```
    (?).get_entities().matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities not having the specified nbt
    > 
    > Params:
    >   - **nbt**: The required nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_team
    ```
    (?).get_entities().not_in_team(team: str!)
    ```
    > FILTER: Filter out all entities in the specified team
    > 
    > Params:
    >   - **team**: The name of the team valid entities must not be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_matching_nbt
    ```
    (?).get_entities().not_matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities matching the specified nbt
    > 
    > Params:
    >   - **nbt**: The prohibited nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_of_type
    ```
    (?).get_entities().not_of_type(entity_type: str!)
    ```

  * ### of_name
    ```
    (?).get_entities().of_name(name: str!)
    ```
    > FILTER: Filter out all entities not named the specified name
    > 
    > Params:
    >   - **name**: The entity name passing entities have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### of_type
    ```
    (?).get_entities().of_type(entity_type: str!)
    ```
    > FILTER: Filter out all entities not matching the specified type
    > 
    > Params:
    >   - **entity_type**: The entity type passing entities match
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### passing_predicate
    ```
    (?).get_entities().passing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities not passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities pass
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_hrz_rot
    ```
    (?).get_entities().with_hrz_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified direction
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at south (+z), increasing clockwise required
    >   - **max**: The maximum angle in degrees zeroed at south (+z), increasing clockwise required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_no_team
    ```
    (?).get_entities().with_no_team()
    ```
    > FILTER: Filter out all entities in the any team
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_score
    ```
    (?).get_entities().with_score(score: str!, min: int!? = null, max: int!? = null)
    ```
    > FILTER: Filter out all entities whose specified score is not in range
    > 
    > Params:
    >   - **score**: The scoreboard objective to test
    >   - **min**: The score that a passing entity must have greater than or equal to
    >   - **max**: The score that a passing entity must have less than or equal to
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_tag
    ```
    (?).get_entities().with_tag(tag: str!)
    ```
    > FILTER: Filter out all entities with the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_vert_rot
    ```
    (?).get_entities().with_vert_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified pitch
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at horizontal, increasing down required
    >   - **max**: The maximum angle in degrees zeroed at horizontal, increasing down required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### without_tag
    ```
    (?).get_entities().without_tag(tag: str!)
    ```
    > FILTER: Filter out all entities lacking the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must not have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### find
    ```
    world.get_entities().find()
    ```
    > Get real entities from a partial selector
    > 
    > Returns:
    >   - The selected Entities
* ### get_entity
  ```
  (?).get_entity(sort: str! = nearest)
  ```
  > Begin a partial selector targeting one entity that matches the filters
  > 
  > Params:
  >   - **sort**: How to handle multiple valid entities.  Options include: nearest, furthest, random, arbitrary
  > 
  > Returns:
  >   - Partial Selector for Entities
  * ### failing_predicate
    ```
    (?).get_entity(sort: str! = nearest).failing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities fail
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### from_position
    ```
    (?).get_entity(sort: str! = nearest).from_position(x: int!, y: int!, z: int!)
    ```
    > FILTER: Move the coordinates the selector tests from to set coordinates rather than executor coordinates
    > 
    > Params:
    >   - **x**: The x coordinate to originate location based selections at
    >   - **y**: The y coordinate to originate location based selections at
    >   - **z**: The z coordinate to originate location based selections at
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_radius
    ```
    (?).get_entity(sort: str! = nearest).in_radius(min: float!? = null, max: float!? = null)
    ```
    > FILTER: Filter out all entities not between the min and max distance
    > 
    > Params:
    >   - **min**: The minimum distance
    >   - **max**: The maximum distance
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_team
    ```
    (?).get_entity(sort: str! = nearest).in_team(team: str!?)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **team**: The name of the team valid entities must be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_volume
    ```
    (?).get_entity(sort: str! = nearest).in_volume(dx: int!, dy: int!, dz: int!)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **dx**: Makes the offset point `dx` away from the selector location
    >   - **dy**: Makes the offset point `dy` away from the selector location
    >   - **dz**: Makes the offset point `dz` away from the selector location
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### matching_nbt
    ```
    (?).get_entity(sort: str! = nearest).matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities not having the specified nbt
    > 
    > Params:
    >   - **nbt**: The required nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_team
    ```
    (?).get_entity(sort: str! = nearest).not_in_team(team: str!)
    ```
    > FILTER: Filter out all entities in the specified team
    > 
    > Params:
    >   - **team**: The name of the team valid entities must not be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_matching_nbt
    ```
    (?).get_entity(sort: str! = nearest).not_matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities matching the specified nbt
    > 
    > Params:
    >   - **nbt**: The prohibited nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_of_type
    ```
    (?).get_entity(sort: str! = nearest).not_of_type(entity_type: str!)
    ```

  * ### of_name
    ```
    (?).get_entity(sort: str! = nearest).of_name(name: str!)
    ```
    > FILTER: Filter out all entities not named the specified name
    > 
    > Params:
    >   - **name**: The entity name passing entities have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### of_type
    ```
    (?).get_entity(sort: str! = nearest).of_type(entity_type: str!)
    ```
    > FILTER: Filter out all entities not matching the specified type
    > 
    > Params:
    >   - **entity_type**: The entity type passing entities match
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### passing_predicate
    ```
    (?).get_entity(sort: str! = nearest).passing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities not passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities pass
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_hrz_rot
    ```
    (?).get_entity(sort: str! = nearest).with_hrz_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified direction
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at south (+z), increasing clockwise required
    >   - **max**: The maximum angle in degrees zeroed at south (+z), increasing clockwise required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_no_team
    ```
    (?).get_entity(sort: str! = nearest).with_no_team()
    ```
    > FILTER: Filter out all entities in the any team
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_score
    ```
    (?).get_entity(sort: str! = nearest).with_score(score: str!, min: int!? = null, max: int!? = null)
    ```
    > FILTER: Filter out all entities whose specified score is not in range
    > 
    > Params:
    >   - **score**: The scoreboard objective to test
    >   - **min**: The score that a passing entity must have greater than or equal to
    >   - **max**: The score that a passing entity must have less than or equal to
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_tag
    ```
    (?).get_entity(sort: str! = nearest).with_tag(tag: str!)
    ```
    > FILTER: Filter out all entities with the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_vert_rot
    ```
    (?).get_entity(sort: str! = nearest).with_vert_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified pitch
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at horizontal, increasing down required
    >   - **max**: The maximum angle in degrees zeroed at horizontal, increasing down required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### without_tag
    ```
    (?).get_entity(sort: str! = nearest).without_tag(tag: str!)
    ```
    > FILTER: Filter out all entities lacking the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must not have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### find
    ```
    world.get_entity(sort: str! = nearest).find()
    ```
    > Get a real entity from a partial selector
    > 
    > Returns:
    >   - The selected Entity
* ### get_player
  ```
  (?).get_player(sort: str! = nearest)
  ```
  > Begin a partial selector targeting one player that matches the filters
  > 
  > Params:
  >   - **sort**: How to handle multiple valid players.  Options include: nearest, furthest, random, arbitrary
  > 
  > Returns:
  >   - Partial Selector for a Player
  * ### advancement_matches
    ```
    (?).get_player(sort: str! = nearest).advancement_matches(advancement: str!)
    ```
    > FILTER: Filter out all players who gamemode is not the specified one
    > 
    > Params:
    >   - **advancement**: The advancement (or advancement criteria) the player must match
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### failing_predicate
    ```
    (?).get_player(sort: str! = nearest).failing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities fail
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### from_position
    ```
    (?).get_player(sort: str! = nearest).from_position(x: int!, y: int!, z: int!)
    ```
    > FILTER: Move the coordinates the selector tests from to set coordinates rather than executor coordinates
    > 
    > Params:
    >   - **x**: The x coordinate to originate location based selections at
    >   - **y**: The y coordinate to originate location based selections at
    >   - **z**: The z coordinate to originate location based selections at
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_gamemode
    ```
    (?).get_player(sort: str! = nearest).in_gamemode(mode: str!)
    ```
    > FILTER: Filter out all players whose gamemode is not the specified one
    > 
    > Params:
    >   - **mode**: The gamemode players must be in
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_radius
    ```
    (?).get_player(sort: str! = nearest).in_radius(min: float!? = null, max: float!? = null)
    ```
    > FILTER: Filter out all entities not between the min and max distance
    > 
    > Params:
    >   - **min**: The minimum distance
    >   - **max**: The maximum distance
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_team
    ```
    (?).get_player(sort: str! = nearest).in_team(team: str!?)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **team**: The name of the team valid entities must be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_volume
    ```
    (?).get_player(sort: str! = nearest).in_volume(dx: int!, dy: int!, dz: int!)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **dx**: Makes the offset point `dx` away from the selector location
    >   - **dy**: Makes the offset point `dy` away from the selector location
    >   - **dz**: Makes the offset point `dz` away from the selector location
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### matching_nbt
    ```
    (?).get_player(sort: str! = nearest).matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities not having the specified nbt
    > 
    > Params:
    >   - **nbt**: The required nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_gamemode
    ```
    (?).get_player(sort: str! = nearest).not_in_gamemode(mode: str!)
    ```
    > FILTER: Filter out all players whose gamemode matches the specified one
    > 
    > Params:
    >   - **mode**: The gamemode players must not be in
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_team
    ```
    (?).get_player(sort: str! = nearest).not_in_team(team: str!)
    ```
    > FILTER: Filter out all entities in the specified team
    > 
    > Params:
    >   - **team**: The name of the team valid entities must not be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_matching_nbt
    ```
    (?).get_player(sort: str! = nearest).not_matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities matching the specified nbt
    > 
    > Params:
    >   - **nbt**: The prohibited nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### of_name
    ```
    (?).get_player(sort: str! = nearest).of_name(name: str!)
    ```
    > FILTER: Filter out all entities not named the specified name
    > 
    > Params:
    >   - **name**: The entity name passing entities have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### passing_predicate
    ```
    (?).get_player(sort: str! = nearest).passing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities not passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities pass
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_hrz_rot
    ```
    (?).get_player(sort: str! = nearest).with_hrz_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified direction
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at south (+z), increasing clockwise required
    >   - **max**: The maximum angle in degrees zeroed at south (+z), increasing clockwise required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_level
    ```
    (?).get_player(sort: str! = nearest).with_level(min: int!, max: int!)
    ```
    > FILTER: Filter out all players whose level is not within the specified range 
    > 
    > Params:
    >   - **min**: The minimum level players must have
    >   - **max**: The maximum level players must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_no_team
    ```
    (?).get_player(sort: str! = nearest).with_no_team()
    ```
    > FILTER: Filter out all entities in the any team
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_score
    ```
    (?).get_player(sort: str! = nearest).with_score(score: str!, min: int!? = null, max: int!? = null)
    ```
    > FILTER: Filter out all entities whose specified score is not in range
    > 
    > Params:
    >   - **score**: The scoreboard objective to test
    >   - **min**: The score that a passing entity must have greater than or equal to
    >   - **max**: The score that a passing entity must have less than or equal to
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_tag
    ```
    (?).get_player(sort: str! = nearest).with_tag(tag: str!)
    ```
    > FILTER: Filter out all entities with the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_vert_rot
    ```
    (?).get_player(sort: str! = nearest).with_vert_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified pitch
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at horizontal, increasing down required
    >   - **max**: The maximum angle in degrees zeroed at horizontal, increasing down required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### without_tag
    ```
    (?).get_player(sort: str! = nearest).without_tag(tag: str!)
    ```
    > FILTER: Filter out all entities lacking the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must not have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### find
    ```
    world.get_player(sort: str! = nearest).find()
    ```
    > Get a real player from a partial selector
    > 
    > Returns:
    >   - The selected player
* ### get_players
  ```
  (?).get_players()
  ```
  > Begin a partial selector targeting all players that match the filters
  > 
  > Returns:
  >   - Partial Selector for Player Groups
  * ### advancement_matches
    ```
    (?).get_players().advancement_matches(advancement: str!)
    ```
    > FILTER: Filter out all players who gamemode is not the specified one
    > 
    > Params:
    >   - **advancement**: The advancement (or advancement criteria) the player must match
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### failing_predicate
    ```
    (?).get_players().failing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities fail
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### from_position
    ```
    (?).get_players().from_position(x: int!, y: int!, z: int!)
    ```
    > FILTER: Move the coordinates the selector tests from to set coordinates rather than executor coordinates
    > 
    > Params:
    >   - **x**: The x coordinate to originate location based selections at
    >   - **y**: The y coordinate to originate location based selections at
    >   - **z**: The z coordinate to originate location based selections at
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_gamemode
    ```
    (?).get_players().in_gamemode(mode: str!)
    ```
    > FILTER: Filter out all players whose gamemode is not the specified one
    > 
    > Params:
    >   - **mode**: The gamemode players must be in
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_radius
    ```
    (?).get_players().in_radius(min: float!? = null, max: float!? = null)
    ```
    > FILTER: Filter out all entities not between the min and max distance
    > 
    > Params:
    >   - **min**: The minimum distance
    >   - **max**: The maximum distance
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_team
    ```
    (?).get_players().in_team(team: str!?)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **team**: The name of the team valid entities must be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### in_volume
    ```
    (?).get_players().in_volume(dx: int!, dy: int!, dz: int!)
    ```
    > FILTER: Filter out all entities not in the volume bounded by the selector location and a point offset from the selector location
    > 
    > Params:
    >   - **dx**: Makes the offset point `dx` away from the selector location
    >   - **dy**: Makes the offset point `dy` away from the selector location
    >   - **dz**: Makes the offset point `dz` away from the selector location
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### matching_nbt
    ```
    (?).get_players().matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities not having the specified nbt
    > 
    > Params:
    >   - **nbt**: The required nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_gamemode
    ```
    (?).get_players().not_in_gamemode(mode: str!)
    ```
    > FILTER: Filter out all players whose gamemode matches the specified one
    > 
    > Params:
    >   - **mode**: The gamemode players must not be in
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_in_team
    ```
    (?).get_players().not_in_team(team: str!)
    ```
    > FILTER: Filter out all entities in the specified team
    > 
    > Params:
    >   - **team**: The name of the team valid entities must not be a member of
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### not_matching_nbt
    ```
    (?).get_players().not_matching_nbt(nbt: str!)
    ```
    > FILTER: Filter out all entities matching the specified nbt
    > 
    > Params:
    >   - **nbt**: The prohibited nbt
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### of_name
    ```
    (?).get_players().of_name(name: str!)
    ```
    > FILTER: Filter out all entities not named the specified name
    > 
    > Params:
    >   - **name**: The entity name passing entities have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### passing_predicate
    ```
    (?).get_players().passing_predicate(predicate: str!)
    ```
    > FILTER: Filter out all entities not passing the specified predicate
    > 
    > Params:
    >   - **predicate**: The predicate passing entities pass
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_hrz_rot
    ```
    (?).get_players().with_hrz_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified direction
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at south (+z), increasing clockwise required
    >   - **max**: The maximum angle in degrees zeroed at south (+z), increasing clockwise required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_level
    ```
    (?).get_players().with_level(min: int!, max: int!)
    ```
    > FILTER: Filter out all players whose level is not within the specified range 
    > 
    > Params:
    >   - **min**: The minimum level players must have
    >   - **max**: The maximum level players must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_no_team
    ```
    (?).get_players().with_no_team()
    ```
    > FILTER: Filter out all entities in the any team
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_score
    ```
    (?).get_players().with_score(score: str!, min: int!? = null, max: int!? = null)
    ```
    > FILTER: Filter out all entities whose specified score is not in range
    > 
    > Params:
    >   - **score**: The scoreboard objective to test
    >   - **min**: The score that a passing entity must have greater than or equal to
    >   - **max**: The score that a passing entity must have less than or equal to
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_tag
    ```
    (?).get_players().with_tag(tag: str!)
    ```
    > FILTER: Filter out all entities with the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### with_vert_rot
    ```
    (?).get_players().with_vert_rot(min: int!, max: int!)
    ```
    > FILTER: Filter out all entities not looking in the specified pitch
    > 
    > Params:
    >   - **min**: The minimum angle in degrees zeroed at horizontal, increasing down required
    >   - **max**: The maximum angle in degrees zeroed at horizontal, increasing down required
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### without_tag
    ```
    (?).get_players().without_tag(tag: str!)
    ```
    > FILTER: Filter out all entities lacking the specified tag
    > 
    > Params:
    >   - **tag**: The name of the tag valid entities must not have
    > 
    > Returns:
    >   - Partial Selector of same type as predecessor (this allows unlimited chaining of filters)
  * ### find
    ```
    world.get_players().find()
    ```
    > Get real players from a partial selector
    > 
    > Returns:
    >   - The selected players
* ### meta
  ```
  (?).meta
  ```

  * ### compile_time
    ```
    world.meta.compile_time
    ```

* ### pos
  ```
  (?).pos
  ```

  * ### constant
    ```
    world.pos.constant(x: float!, y: float!, z: float!)
    ```

  * ### get
    ```
    Entities.pos.get(dx: float! = 0, dy: float! = 0, dz: float! = 0)
    ```

  * ### get_directed
    ```
    Entities.pos.get_directed(rx: float! = 0, ry: float! = 0, rz: float! = 0)
    ```

  * ### set_coord
    ```
    world.pos.set_coord(old_pos: std::Pos, force_x: float!? = null, force_y: float!? = null, force_z: float!? = null)
    ```

* ### rotate
  ```
  (?).rotate
  ```
  > Entity Rotation related functions
  * ### face
    ```
    Entities.rotate.face(target_loc: std::Pos)
    ```
    > Makes the executing entities look towards the target location
    > 
    > Params:
    >   - **target_loc**: The location to look towards
  * ### match
    ```
    Entities.rotate.match(target_entity: Entity)
    ```
    > Makes the executing entities look in the same direction as the target entity
    > 
    > Params:
    >   - **target_entity**: The entity to match the rotation of
  * ### set
    ```
    Entities.rotate.set(horizontal: float!, vertical: float!)
    ```
    > Makes the executing entities look in a specific direction
    > 
    > Params:
    >   - **horizontal**: The horizontal rotation to take in degrees starting from due south (+z) increasing clockwise
    >   - **vertical**: The vertical rotation to take in degrees starting from looking towards the horizon, negative values indicate degrees above the horizon
* ### scoreboard
  ```
  (?).scoreboard
  ```

  * ### conf
    ```
    (?).scoreboard.conf
    ```

    * ### display
      ```
      (?).scoreboard.conf.display
      ```

      * ### below_name
        ```
        world.scoreboard.conf.display.below_name(name: str!?)
        ```

      * ### list
        ```
        world.scoreboard.conf.display.list(name: str!?)
        ```

      * ### sidebar
        ```
        world.scoreboard.conf.display.sidebar(name: str!?, team_color: str!? = null)
        ```

    * ### hearts
      ```
      world.scoreboard.conf.hearts(obj_name: str!, list_as_hearts: bool!)
      ```

    * ### json_name
      ```
      world.scoreboard.conf.json_name(obj_name: str!)
      ```

  * ### obj
    ```
    (?).scoreboard.obj(obj_name: str!)
    ```

    * ### player
      ```
      (?).scoreboard.obj(obj_name: str!).player(fake_player: str!)
      ```

      * ### add
        ```
        world.scoreboard.obj(obj_name: str!).player(fake_player: str!).add(value: int)
        ```

      * ### get
        ```
        world.scoreboard.obj(obj_name: str!).player(fake_player: str!).get()
        ```

      * ### reset
        ```
        world.scoreboard.obj(obj_name: str!).player(fake_player: str!).reset()
        ```

      * ### set
        ```
        world.scoreboard.obj(obj_name: str!).player(fake_player: str!).set(value: int)
        ```

      * ### sub
        ```
        world.scoreboard.obj(obj_name: str!).player(fake_player: str!).sub(value: int)
        ```

    * ### add
      ```
      Entities.scoreboard.obj(obj_name: str!).add(value: int)
      ```

    * ### enable
      ```
      Entities.scoreboard.obj(obj_name: str!).enable()
      ```

    * ### get
      ```
      Entity.scoreboard.obj(obj_name: str!).get()
      ```

    * ### reset
      ```
      Entities.scoreboard.obj(obj_name: str!).reset()
      ```

    * ### set
      ```
      Entities.scoreboard.obj(obj_name: str!).set(value: int)
      ```

    * ### sub
      ```
      Entities.scoreboard.obj(obj_name: str!).sub(value: int)
      ```

  * ### add_obj
    ```
    world.scoreboard.add_obj(name: str!, obj_type: str! = dummy)
    ```

  * ### remove_obj
    ```
    world.scoreboard.remove_obj(name: str!)
    ```

  * ### reset
    ```
    Entities.scoreboard.reset()
    ```

## Structs
* `std::Color`

* `std::Pos`
  > Stores a position in the world for later reference
